# This script runs on gitlab.ebi.ac.uk
# https://gitlab.ebi.ac.uk/emblorg/vf-core-mirror

variables:
  # set secrets in Settings -> Pipelines -> Secret Variables
  GIT_SUBMODULE_STRATEGY: recursive
  DOCKER_DRIVER: overlay2
  GIT_STRATEGY: fetch
  CS_DOCKERFILE_PATH: $CI_PROJECT_DIR/Dockerfile

before_script:
  - echo "Loading .env file..."     # Inform about loading environment variables
  - set -a                         # Export all variables loaded from .env
  - source ./.env                  # Load environment variables from .env file
  - set +a                         # Stop exporting all variables
  - export DOCKER_PROJECT_NAME="${PROJECT_NAME//./-}" # Replace dots with dashes for Docker image naming
  - export CI_COMMIT_SHA_SHORT=${CI_COMMIT_SHA::8}    # Shorten commit SHA for tagging
  - export IMAGE_NGINX=$CI_REGISTRY/$CI_PROJECT_PATH:$DOCKER_PROJECT_NAME-nginx-$CI_COMMIT_SHORT_SHA-$CI_PIPELINE_ID     # Tag for NGINX image

stages:
  - build
  - deploy

####################################
# BUILD
####################################
.template_build: &build
  stage: build
  tags: [dind] # Docker-in-Docker runner
  script:
    - echo "Building images with the following variables:"
    - echo "IMAGE_NGINX - $IMAGE_NGINX"
    - echo "$CI_JOB_TOKEN" | docker login -u gitlab-ci-token --password-stdin $CI_REGISTRY # Authenticate to Docker registry using token
    - docker build -t $IMAGE_NGINX --build-arg ENV=$ENVIRONMENT -f Dockerfile . # Build NGINX image
    - docker push $IMAGE_NGINX   # Push NGINX image

build_dev:
  stage: build
  rules:
    - if: '$CI_COMMIT_REF_NAME == "master"' # Only run on dev branch
  variables:
    ENVIRONMENT: dev
  <<: *build

build_prod:
  stage: build
  rules:
    - if: '$CI_COMMIT_TAG' # Only run on tag (production)
  variables:
    ENVIRONMENT: prod
  <<: *build

####################################
# DEPLOY + POST-DEPLOY DRUSH
####################################
.template_deploy: &deploy
  image: ebiwd/alpine-ssh:3.20
  script:
    - mkdir -p $HOME/.kube # Prepare kube config directory
    - echo -n $KUBE_CONFIG | base64 -d > $HOME/.kube/config # Decode and write kube config
    # Inject environment variables and prepare k8s overlays
    - cp ./.env k8s/overlays/$ENVIRONMENT/.env # Copy .env to k8s overlay
    - mkdir -p k8s/base/config # Create config directory if it doesn't exist
    # Select appropriate Database config file based on environment and DB datacenter
    - echo "Env - $ENVIRONMENT"
    - |
      if [ "$ENVIRONMENT" = "dev" ]; then
        NAMESPACE="$PROJECT_NAMESPACE_DEV"
      elif [ "$ENVIRONMENT" = "prod" ]; then
        NAMESPACE="$PROJECT_NAMESPACE_PROD"
      else
        echo "Invalid configuration"; exit 1
      fi
      echo "Using Kubernetes namespace: $NAMESPACE"
    # Update Kubernetes manifests with built image tags and NFS paths
    - |
      for file in k8s/base/*.yaml; do
        sed -i \
          -e "s|{{PROJECT_NAME}}|${PROJECT_NAME}|g" \
          -e "s|{{NGINX_IMAGE}}|$IMAGE_NGINX|g" \
          "$file"
      done
    - echo "ðŸš€ Deploying application"
    - kubectl kustomize k8s/overlays/$ENVIRONMENT | envsubst | kubectl --namespace=$NAMESPACE apply -f - # Deploy application
  
deploy_dev:
  stage: deploy
  rules:
    - if: '$CI_COMMIT_REF_NAME == "master"' # Only run on dev branch
  variables:
    KUBE_CONFIG: $HH_EBIWD_STATIC_KUBE_CONFIG # Kube config secret for dev
    ENVIRONMENT: dev
  needs: [build_dev]
  <<: *deploy

deploy_prod_hh:
  stage: deploy
  rules:
    - if: '$CI_COMMIT_TAG' # Only run on tag (production)
  variables:
    KUBE_CONFIG: $HH_EBIWD_STATIC_KUBE_CONFIG # Kube config secret for prod (hh)
    ENVIRONMENT: prod
  needs: [build_prod]
  <<: *deploy

deploy_prod_hx:
  stage: deploy
  rules:
    - if: '$CI_COMMIT_TAG' # Only run on tag (production)
  variables:
    KUBE_CONFIG: $HX_EBIWD_STATIC_KUBE_CONFIG # Kube config secret for prod (hx)
    ENVIRONMENT: prod
  needs: [build_prod_hx]
  <<: *deploy
